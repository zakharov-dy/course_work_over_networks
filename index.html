<!DOCTYPE html>
<html>
<head>
   <meta charset="utf-8">
   <title>Курсовая работа</title>
   <script src="source/jquery-2.1.4.min.js" charset="utf-8"></script>
   <script src="source/bootstrap-3.3.5-dist/js/bootstrap.min.js" charset="utf-8"></script>
   <script src="source/main.js" charset="utf-8"></script>
   <link rel="stylesheet" href="source/bootstrap-3.3.5-dist/css/bootstrap.min.css">
   <link rel="stylesheet" href="source/bootstrap_upgrade.css">
   <link rel="stylesheet" href="source/main.css">

</head>
<body>
<div class="cs-navbar">
   <div class="container">
      <nav class="navbar navbar-static-top cs-navbar-content">
         <div class="navbar-header">
            <p class="navbar-brand" id="paragraph-title"></p>
         </div>

         <div class="container-fluid">

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
               <ul class="nav navbar-nav">
                  <li><a href="#" class="cs-head" id="p-title-page"><span class="glyphicon glyphicon-file"></span> Титульная страница </a></li>
                  <li><a href="#" class="cs-head" id="p-bibliography"><span class="glyphicon glyphicon-book" ></span> Список литературы </a></li>
               </ul>
            </div>
         </div>
      </nav>
   </div>
</div>

<div class="container cs-content">
   <div class="col-lg-3 col-md-3">
      <div class="panel-group cs-menu" id='accordion' role="tablist" aria-multiselectable="true">
         <div class="panel panel-default">
            <div class="panel-heading" role="tab" id="collapseListGroupHeading">
               <h4 class="panel-title">
                  <a class="collapsed" role="button" data-toggle="collapse" href="#collapseListGroup" aria-expanded="false" aria-controls="collapseListGroup" data-parent="#accordion">
                     Протокол HTTP
                  </a>
               </h4>
            </div>
            <div id="collapseListGroup" class="panel-collapse collapse" role="tabpanel" aria-labelledby="collapseListGroupHeading" aria-expanded="false" style="height: 0px;">
               <ul class="list-group">
                  <li class="list-group-item">
                     <a href="#" class="cs-head" id="p-HTTP">
                        Общие сведения о HTTP
                     </a>
                  </li>
                  <li class="list-group-item">
                     <a href="#" class="cs-head" id="p-HTTP-struct">
                        Структура HTTP пакета
                     </a>
                  </li>
                  <li class="list-group-item">
                     <a href="#" class="cs-head" id="">
                        Протокол SOAP
                     </a>
                  </li>
                  <li class="list-group-item">
                     <a href="#" class="cs-head" id="p-rest">
                        REST архитектура
                     </a>
                  </li>
               </ul>
            </div>
         </div>
         <div class="panel panel-default">
            <div class="panel-heading" role="tab" id="collapseListGroupHeading1">
               <h4 class="panel-title">
                  <a class="" role="button" data-toggle="collapse" href="#collapseListGroup1" aria-expanded="true" aria-controls="collapseListGroup1" data-parent="#accordion">
                     Языки программирования и фреймворки
                  </a>
               </h4>
            </div>
            <div id="collapseListGroup1" class="panel-collapse collapse" role="tabpanel" aria-labelledby="collapseListGroupHeading1" aria-expanded="true">
               <ul class="list-group">
                  <li class="list-group-item">
                     <a href="#" class="cs-head" id="p-cl-srv-architecture">Понятие о клиент-сервернй архитектуре Веб-приложений
                     </a>
                  </li>
                  <li class="list-group-item">
                     <a href="#" class="cs-head" id="p-web-standarts">
                        Стандарты
                        веб-технологий
                     </a>
                  </li>
                  <li class="list-group-item">
                     <a href="#" class="cs-head" id="p-html">
                        HTML
                     </a>
                  </li>
                  <li class="list-group-item">
                     <a href="#" class="cs-head" id="p-css">
                        CSS
                     </a>
                  </li>
                  <li class="list-group-item">
                     <a href="#" class="cs-head" id="p-javascript">
                        JavaScript
                     </a>
                  </li>
                  <li class="list-group-item">
                     <a href="#" class="cs-head" id="p-front-end-frameworks">
                        Основные понятия о front-end фреймворках
                     </a>
                  </li>
                  <li class="list-group-item">
                     <a href="#" class="cs-head" id="p-back-end-frameworks">
                        Back-end и back-end фреймворки
                     </a>
                  </li>
               </ul>
            </div>
         </div>
         <div class="panel panel-default">
            <div class="panel-heading" role="tab" id="collapseListGroupHeading2">
               <h4 class="panel-title">
                  <a class="" role="button" data-toggle="collapse" href="#collapseListGroup2" aria-expanded="true" aria-controls="collapseListGroup2" data-parent="#accordion">
                     Веб-серверы
                  </a>
               </h4>
            </div>
            <div id="collapseListGroup2" class="panel-collapse collapse" role="tabpanel" aria-labelledby="collapseListGroupHeading2" aria-expanded="true">
               <ul class="list-group">
                  <li class='list-group-item'>
                     <a href="#" class="cs-head" id="p-web-srv">
                        Принципы работы веб-серверов
                     </a>
                  </li>
                  <li class='list-group-item'>
                     <a href="#" class="cs-head" id="p-server-farm">
                        Серверные фермы и балансировка нагрузки
                     </a>
                  </li>
                  <li class='list-group-item'>
                     <a href="#" class="cs-head" id="p-web-proxy">
                        Веб-прокси
                     </a>
                  </li>
                  <li class='list-group-item'>
                     <a href="#" class="cs-head" id="p-modern-web-srv">
                        Современные веб-серверы
                     </a>
                  </li>
               </ul>
            </div>
         </div>
      </div>
      <div id="cs-footer">
         <div class=" panel panel-heading panel-primary">
            <span class="glyphicon glyphicon-chevron-up"></span> Наверх
         </div>
      </div>
   </div>
   <div id="paragraph-content" class="col-lg-9 col-md-9">

   </div>
   <div class="container cs-container-bottom">
      <div class="container">
         <div class="col-lg-3 col-md-3">

         </div>
      </div>
   </div>
</div>





















<div class="cs-paragraph" id="bibliography">
   <div class="paragraph-header">Список литературы</div>
   <div class="paragraph-body">
      <h2 class="text-center">Список литературы</h2>
      <ol>
         <li>Компьютерные сети. 5-е изд. / Э. Таненбаум. — СПб.: Питер, 2012. — 960 с.: ил.  – (Серия «Классика Computer Science»).</li>
         <li>Компьютерные сети. Принципы, технологии, протоколы . 3-е изд./ В. Г. Олифер, Н. А. Олифер. – СПб.: Питер, 2006. – 958 с.: ил.</li>
         <li>Мировые информационные ресурсы. - ИНТУИТ, 2013. - 441 с.</li>
         <li>Rails 4. Гибкая разработка веб-приложений. — СПб.: Питер, 2014. — 448 с.: ил. — (Серия «Для профессионалов»).</li>
         <li>JavaScript: сильные стороны. - Спб.: Питер, 2012. - 176 с.: ил</li>
         <li>Самоучитель HTML в PDF. Влад Мержевич, 2011. - 97с.</li>
         <li>Web-технологии. - Технопарк Mail.ru Group. [Видеокурс]. - Режим доступа: http://www.intuit.ru/studies/courses/3668/910/info, свободный.</li>
         <li>Обзор JS-фреймворков. [Электронный ресурс]. – Режим доступа: http://habrahabr.ru/post/149594/, свободный.</li>
         <li>30 CSS-фреймворков для адаптивного веб-дизайна. [Электронный ресурс]. – Режим доступа: http://habrahabr.ru/post/156747/, свободный.</li>
         <li>Веб-стандарты. [Электронный ресурс]. – Режим доступа: https://developer.mozilla.org/ru/docs/Веб-стандарты, свободный.</li>
         <li>Сравнение веб-серверов [Электронный ресурс]. – Режим доступа: https://ru.wikipedia.org/wiki/Сравнение_веб-серверов, свободный.</li>
      </ol>
   </div>
</div>

<div class="cs-paragraph" id="title-page">
   <div class="paragraph-header">Титульная страница</div>
   <div class="paragraph-body">
      <h4 class="text-center"><b>ГОУВПО</b></h4>
      <h4 class="text-center"><b>Уфимский государственный авиационный технический университет</b></h4>
      <p class="text-right cs-title-department">Кафедра вычислительной техники и защиты информации</p>
      <h3 class="text-center">Курсовая работа по дисциплине "Сети и системы передачи данных"</h3>
      <h3 class="text-center"></h3>
      <h2 class="text-center cs-title-name">"Анализ современных web-технологий и протокола HTTP.
         Языки и средства создания web-приложений. Современные Веб серверы."</h2>
      <p class="text-left">Выполнил: студент гр. БПС-403</p>
      <p class="text-left">Д. Ю. Захаров</p>
      <p class="text-left">Проверил: кандидат физико-математических наук, доцент</p>
      <p class="text-left">Р. А. Гараев</p>
      <p class="text-center cs-title-age">Уфа 2015</p>
   </div>
</div>
<div class="cs-paragraph" id="">
   <div class="paragraph-header">Структура HTTP пакета</div>
   <div class="paragraph-body">
      <h2 class="text-center">Структура HTTP пакета</h2>
      <h3>Три части HTTP</h3>
      <p>Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:</p>
      <ul>
         <li>Первая строка - определяет тип сообщения;</li>
         <li>Заголовки - разная полезная информация, которая характеризует тело сообщения, параметры передачи и прочие сведения;</li>
         <li>Тело сообщения - это сгенерированный html-код, который браузер потом будет отображать. Обязательно должно отделяться от заголовков пустой строкой.</li>
      </ul>
      <img src="source/http.jpg" alt="" class="img-responsive">
      <div class="row">
         <div class="col-lg-6 col-md-6">
            <h3>HTTP-запрос</h3>
            <ul>
               <li>Метод - название запроса, одно слово заглавными буквами;
               </li>
               <li>URI - определяет путь к запрашиваемому документ</li>
               <li>Версия - пара разделённых точкой арабских цифр. Например: 1.1</li>
            </ul>
         </div>
         <div class="col-lg-6 col-md-6">
            <h3>HTTP-ответ</h3>
            <ul>
               <li>Версия - пара разделённых точкой арабских цифр, как в запросе;</li>
               <li>Код состояния - три цифры. По коду состояния определяеться дальнейшее содержимое сообщения и поведение клиента;</li>
               <li>Пояснение - текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и являеться не обязательным.</li>
            </ul>
         </div>
         <h3>Методы HTTP</h3>
         <table class="table">
            <tbody><tr>
               <td>GET</td>
               <td>позволяет получить информацию от сервера, тело запроса всегда остается пустым;</td>
            </tr>
            <tr>
               <td>HEAD</td>
               <td>аналогичен GET, но тело ответа остается всегда пустым, позволяет проверить доступность запрашиваемого ресурса и прочитать HTTP-заголовки ответа;</td>
            </tr>
            <tr>
               <td>POST</td>
               <td>позволяет загрузить информацию на сервер, по смыслу изменяет ресурс на сервере, но зачастую используется и для создания ресурса на сервере, тело запроса содержит изменяемый/создаваемый ресурс;</td>
            </tr>
            <tr>
               <td>PUT</td>
               <td>аналогичен POST, но по смыслу занимается созданием ресурса, а не его изменением, тело запроса содержит создаваемый ресурс;</td>
            </tr>
            <tr>
               <td>DELETE</td>
               <td>удаляет ресурс с сервера.</td>
            </tr>
            </tbody>
         </table>
         <h3>Группы кодов состояния, содержащиеся в ответах сервера</h3>
         <table class="table">
            <thead>
            <tr>
               <td>Код</td>
               <td>Значение</td>
               <td>Примеры</td>
            </tr>
            </thead>
            <tbody>
            <tr>
               <td>1xx</td>
               <td>Информация</td>
               <td>100 = сервер согласен обрабатывать запросы клиента</td>
            </tr>
            <tr>
               <td>2xx</td>
               <td>Успех</td>
               <td>200 = запрос успешно обработан; 204 = содержимое отсутствует </td>
            </tr>
            <tr>
               <td>3xx</td>
               <td>Перенаправление</td>
               <td>301 = страница перемещена; 304 = кэшированная страница все еще доступна</td>
            </tr>
            <tr>
               <td>4xx</td>
               <td>Ошибка клиента</td>
               <td>403 = ошибка доступа; 404 = страница не найдена</td>
            </tr>
            <tr>
               <td>5xx</td>
               <td>Ошибка сервера</td>
               <td>500 = внутренняя ошибка сервера; 503 = попробуйте еще раз позднее</td>
            </tr>
            </tbody>
         </table>

         <h3>Некоторые заголовки сообщений протокола HTTP</h3>
         <table class="table">
            <thead>
            <tr>
               <td>Заголовок</td>
               <td>Тип</td>
               <td>Содержимое</td>
            </tr>
            </thead>
            <tbody>
            <tr>
               <td>User-Agent</td>
               <td>Запрос</td>
               <td>Информация о браузере и его платформе</td>
            </tr>
            <tr>
               <td>Accept</td>
               <td>Запрос</td>
               <td>Тип страниц, поддерживаемых клиентом</td>
            </tr>
            <tr>
               <td>Accept-Charset</td>
               <td>Запрос</td>
               <td>Поддерживаемые клиентом наборы символов</td>
            </tr>
            <tr>
               <td>Accept-Encoding</td>
               <td>Запрос</td>
               <td>Поддерживаемые клиентом типы кодирования</td>
            </tr>
            <tr>
               <td>Accept-Language</td>
               <td>Запрос</td>
               <td>Естественные языки, понимаемые клиентом</td>
            </tr>
            <tr>
               <td>If-Modified-Since</td>
               <td>Запрос</td>
               <td>Время и дата последнего обновления</td>
            </tr>
            <tr>
               <td>If-None-Match</td>
               <td>Запрос</td>
               <td>Теги, отосланные с последнего обновления</td>
            </tr>
            <tr>
               <td>Host</td>
               <td>Запрос</td>
               <td>DNS-имя сервера</td>
            </tr>
            <tr>
               <td>Authorization</td>
               <td>Запрос</td>
               <td>Список персональных идентификаторов клиента</td>
            </tr>
            <tr>
               <td>Referer</td>
               <td>Запрос</td>
               <td>URL, с которого был отправлен предыдущий запрос</td>
            </tr>
            <tr>
               <td>Cookie</td>
               <td>Запрос</td>
               <td>Отправка ранее принятого cookie-файла на сервер</td>
            </tr>
            <tr>
               <td>Set-Cookie</td>
               <td>Ответ</td>
               <td>Сервер хочет, чтобы клиент сохранил cookie</td>
            </tr>
            <tr>
               <td>Server</td>
               <td>Ответ</td>
               <td>Информация о сервере</td>
            </tr>
            <tr>
               <td>Content-Encoding</td>
               <td>Ответ</td>
               <td>Тип кодирования содержимого (например, gzip)</td>
            </tr>
            <tr>
               <td>Content-Language</td>
               <td>Ответ</td>
               <td>Естественный язык, используемый на странице</td>
            </tr>
            <tr>
               <td>Content-Length</td>
               <td>Ответ</td>
               <td>Размер страницы в байтах</td>
            </tr>
            <tr>
               <td>Last-Modified</td>
               <td>Ответ</td>
               <td>Время и дата внесения последних изменений в страницу</td>
            </tr>
            <tr>
               <td>Expires</td>
               <td>Ответ</td>
               <td>Время и дата, когда страница перестанет считаться действительной</td>
            </tr>
            <tr>
               <td>Accept-Ranges</td>
               <td>Ответ</td>
               <td>Сервер готов принимать запросы на страницы указанного размера</td>
            </tr>
            <tr>
               <td>Date Запрос/</td>
               <td>Ответ</td>
               <td>Дата и время отправки сообщения</td>
            </tr>
            <tr>
               <td>Range</td>
               <td>Запрос/ Ответ</td>
               <td>Идентифицирует часть страницы</td>
            </tr>
            <tr>
               <td>Cache-Control</td>
               <td>Запрос/ Ответ</td>
               <td>Указание на то, как обрабатывать кэш</td>
            </tr>
            <tr>
               <td>ETag</td>
               <td>Запрос/ Ответ</td>
               <td>Тег для контента страницы</td>
            </tr>
            <tr>
               <td>Upgrade</td>
               <td>Запрос/ Ответ</td>
               <td>Протокол, на который хочет переключиться отправитель</td>
            </tr>
            </tbody>
         </table>
      </div>
   </div>
</div>
<div class="cs-paragraph" id="server-farm">
   <div class="paragraph-header">Серверные фермы и балансировка нагрузки</div>
   <div class="paragraph-body">
      <h2 class="text-center">Серверные фермы и балансировка нагрузки</h2>
      <h3>Проблема перегрузки веб-сервера</h3>
      <p>Чтобы построить большие веб-узлы с хорошими характеристиками, мы
         можем увеличивать скорость обработки на серверной стороне, однако
         сколько бы пропускной способности не имела одна машина, она может
         обслуживать только определенное количество сетевых запросов, затем
         она будет перегружена. Для решения такой проблемы можно использовать
         несколько компьютеров, чтобы сделать веб-сервер.</p>
      <h3>Модель серверной фермы</h3>
      <p>Описанная ранее проблема приводит к  модели серверной фермы (server
         farm), показанной на рисунке. Отметим, что  набор компьютеров,
         образующих серверную ферму, должен выглядеть для клиентов как единый
         логический веб-сайт.</p>
      <img src="source/web-farm.png" alt="" class="img-responsive">
      <p>На данной схеме интерфейсная часть названа front-end'ом, как и
         интерфейсная часть веб-приложения. Существует
         несколько возможных решений,
         чтобы набор серверов выглядел как один веб-сайт. Все решения предполагают, что
         каждый из серверов может обрабатывать запрос от любого клиента. Для этого каждый
         сервер должен иметь копию веб-приложения. Пунктирными линиями показано
         соединение
         с этой целью серверов с общей внутренней базой данных.</p>
      <h3>Использование DNS для распределения запросов</h3>
      <p>Одно из решений — использовать DNS для распределения запросов по серверам
         серверной фермы. Когда сделан запрос DNS для URL веб-сайта,
         DNS-сервер возвращает меняющийся список IP-адресов серверов. Каждый клиент обращается к одному
         IP-адресу, обычно к первому в списке. Таким образом, разные клиенты обращаются
         к разным серверам с целью достижения одного и того же веб-узла, как и задумано. Метод
         DNS лежит в основе технологии CDN</p>
      <h3>Использование интерфейсной части для распределения запросов</h3>
      <p>Другие решения основаны на интерфейсной части (front end), которая
         распределяет поступающие запросы по пулу серверов в серверной ферме,
         даже если клиент контактирует с серверной фермой, используя один
         IP-адрес назначения. Интерфейсная часть обычно представляет собой сетевой коммутатор на канальном уровне или
         IP-маршрутизатор, то есть устройство, которое управляет фреймами или пакетами.
         Все решения основаны на том, что эти устройства (или серверы) просматривают
         заголовки сетевого или транспортного уровня или уровня приложений и используют
         их нестандартным образом. Веб-запрос и ответ переносятся как TCP-соединение.
         Чтобы работать правильно, интерфейсная часть должна отправить все пакеты одного
         запроса к одному серверу.</p>
      <h3>Общие сведения о балансировке нагрузки</h3>
      <p>Обычно интерфейсная часть проверяет IP-, TCP-, и HTTP-заголовки пакетов и произвольно распределяет их по серверам. Причина для просмотра TCP-заголовков заключается в том, что в этом случае можно достигнуть лучшего распределения пакетов, чем имея только информацию IP (к примеру, если несколько пользователей сидят под одним и тем же ip, то можно посмотреть порт TCP). Причина для просмотра заголовков HTTP несколько иная. Очень много веб-взаимодействий являются доступом к базам данных и их модификацией. Серверу, который получит этот запрос, придется запросить общую внутреннюю базу данных. Полезно направить последующие запросы от этого же пользователя на тот же сервер, потому что он уже имеет информацию о пользователе в кэше. Самый простой путь для этого — использовать веб-куки. Распределение пакетов называют политикой балансировки нагрузки (load balancing).</p>
   </div>
</div>
<div class="cs-paragraph" id="">
   <div class="paragraph-header"></div>
   <div class="paragraph-body">
   </div>
</div>

<div class="cs-paragraph" id="HTTP-struct">
   <div class="paragraph-header">Структура HTTP пакета</div>
   <div class="paragraph-body">
      <h2 class="text-center">Структура HTTP пакета</h2>
      <h3>Три части HTTP</h3>
      <p>Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:</p>
      <ul>
         <li>Первая строка - определяет тип сообщения;</li>
         <li>Заголовки - разная полезная информация, которая характеризует тело сообщения, параметры передачи и прочие сведения;</li>
         <li>Тело сообщения - это сгенерированный html-код, который браузер потом будет отображать. Обязательно должно отделяться от заголовков пустой строкой.</li>
      </ul>
      <img src="source/http.jpg" alt="" class="img-responsive">
      <div class="row">
         <div class="col-lg-6 col-md-6">
            <h3>HTTP-запрос</h3>
            <ul>
               <li>Метод - название запроса, одно слово заглавными буквами;
               </li>
               <li>URI - определяет путь к запрашиваемому документ</li>
               <li>Версия - пара разделённых точкой арабских цифр. Например: 1.1</li>
            </ul>
         </div>
         <div class="col-lg-6 col-md-6">
            <h3>HTTP-ответ</h3>
            <ul>
               <li>Версия - пара разделённых точкой арабских цифр, как в запросе;</li>
               <li>Код состояния - три цифры. По коду состояния определяеться дальнейшее содержимое сообщения и поведение клиента;</li>
               <li>Пояснение - текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и являеться не обязательным.</li>
            </ul>
         </div>
         <h3>Методы HTTP</h3>
         <table class="table">
            <tbody><tr>
               <td>GET</td>
               <td>позволяет получить информацию от сервера, тело запроса всегда остается пустым;</td>
            </tr>
            <tr>
               <td>HEAD</td>
               <td>аналогичен GET, но тело ответа остается всегда пустым, позволяет проверить доступность запрашиваемого ресурса и прочитать HTTP-заголовки ответа;</td>
            </tr>
            <tr>
               <td>POST</td>
               <td>позволяет загрузить информацию на сервер, по смыслу изменяет ресурс на сервере, но зачастую используется и для создания ресурса на сервере, тело запроса содержит изменяемый/создаваемый ресурс;</td>
            </tr>
            <tr>
               <td>PUT</td>
               <td>аналогичен POST, но по смыслу занимается созданием ресурса, а не его изменением, тело запроса содержит создаваемый ресурс;</td>
            </tr>
            <tr>
               <td>DELETE</td>
               <td>удаляет ресурс с сервера.</td>
            </tr>
            </tbody>
         </table>
         <h3>Группы кодов состояния, содержащиеся в ответах сервера</h3>
         <table class="table">
            <thead>
            <tr>
               <td>Код</td>
               <td>Значение</td>
               <td>Примеры</td>
            </tr>
            </thead>
            <tbody>
            <tr>
               <td>1xx</td>
               <td>Информация</td>
               <td>100 = сервер согласен обрабатывать запросы клиента</td>
            </tr>
            <tr>
               <td>2xx</td>
               <td>Успех</td>
               <td>200 = запрос успешно обработан; 204 = содержимое отсутствует </td>
            </tr>
            <tr>
               <td>3xx</td>
               <td>Перенаправление</td>
               <td>301 = страница перемещена; 304 = кэшированная страница все еще доступна</td>
            </tr>
            <tr>
               <td>4xx</td>
               <td>Ошибка клиента</td>
               <td>403 = ошибка доступа; 404 = страница не найдена</td>
            </tr>
            <tr>
               <td>5xx</td>
               <td>Ошибка сервера</td>
               <td>500 = внутренняя ошибка сервера; 503 = попробуйте еще раз позднее</td>
            </tr>
            </tbody>
         </table>

         <h3>Некоторые заголовки сообщений протокола HTTP</h3>
         <table class="table">
            <thead>
            <tr>
               <td>Заголовок</td>
               <td>Тип</td>
               <td>Содержимое</td>
            </tr>
            </thead>
            <tbody>
            <tr>
               <td>User-Agent</td>
               <td>Запрос</td>
               <td>Информация о браузере и его платформе</td>
            </tr>
            <tr>
               <td>Accept</td>
               <td>Запрос</td>
               <td>Тип страниц, поддерживаемых клиентом</td>
            </tr>
            <tr>
               <td>Accept-Charset</td>
               <td>Запрос</td>
               <td>Поддерживаемые клиентом наборы символов</td>
            </tr>
            <tr>
               <td>Accept-Encoding</td>
               <td>Запрос</td>
               <td>Поддерживаемые клиентом типы кодирования</td>
            </tr>
            <tr>
               <td>Accept-Language</td>
               <td>Запрос</td>
               <td>Естественные языки, понимаемые клиентом</td>
            </tr>
            <tr>
               <td>If-Modified-Since</td>
               <td>Запрос</td>
               <td>Время и дата последнего обновления</td>
            </tr>
            <tr>
               <td>If-None-Match</td>
               <td>Запрос</td>
               <td>Теги, отосланные с последнего обновления</td>
            </tr>
            <tr>
               <td>Host</td>
               <td>Запрос</td>
               <td>DNS-имя сервера</td>
            </tr>
            <tr>
               <td>Authorization</td>
               <td>Запрос</td>
               <td>Список персональных идентификаторов клиента</td>
            </tr>
            <tr>
               <td>Referer</td>
               <td>Запрос</td>
               <td>URL, с которого был отправлен предыдущий запрос</td>
            </tr>
            <tr>
               <td>Cookie</td>
               <td>Запрос</td>
               <td>Отправка ранее принятого cookie-файла на сервер</td>
            </tr>
            <tr>
               <td>Set-Cookie</td>
               <td>Ответ</td>
               <td>Сервер хочет, чтобы клиент сохранил cookie</td>
            </tr>
            <tr>
               <td>Server</td>
               <td>Ответ</td>
               <td>Информация о сервере</td>
            </tr>
            <tr>
               <td>Content-Encoding</td>
               <td>Ответ</td>
               <td>Тип кодирования содержимого (например, gzip)</td>
            </tr>
            <tr>
               <td>Content-Language</td>
               <td>Ответ</td>
               <td>Естественный язык, используемый на странице</td>
            </tr>
            <tr>
               <td>Content-Length</td>
               <td>Ответ</td>
               <td>Размер страницы в байтах</td>
            </tr>
            <tr>
               <td>Last-Modified</td>
               <td>Ответ</td>
               <td>Время и дата внесения последних изменений в страницу</td>
            </tr>
            <tr>
               <td>Expires</td>
               <td>Ответ</td>
               <td>Время и дата, когда страница перестанет считаться действительной</td>
            </tr>
            <tr>
               <td>Accept-Ranges</td>
               <td>Ответ</td>
               <td>Сервер готов принимать запросы на страницы указанного размера</td>
            </tr>
            <tr>
               <td>Date Запрос/</td>
               <td>Ответ</td>
               <td>Дата и время отправки сообщения</td>
            </tr>
            <tr>
               <td>Range</td>
               <td>Запрос/ Ответ</td>
               <td>Идентифицирует часть страницы</td>
            </tr>
            <tr>
               <td>Cache-Control</td>
               <td>Запрос/ Ответ</td>
               <td>Указание на то, как обрабатывать кэш</td>
            </tr>
            <tr>
               <td>ETag</td>
               <td>Запрос/ Ответ</td>
               <td>Тег для контента страницы</td>
            </tr>
            <tr>
               <td>Upgrade</td>
               <td>Запрос/ Ответ</td>
               <td>Протокол, на который хочет переключиться отправитель</td>
            </tr>
            </tbody>
         </table>
      </div>
   </div>
</div>

<div class="cs-paragraph" id="web-proxy">
   <div class="paragraph-header">Общие сведения о Веб-прокси</div>
   <div class="paragraph-body">
      <h2 class="text-center">Общие сведения о Веб-прокси</h2>
      <h3>Зачем нужен Веб-прокси?</h3>
      <p>Ранее было сказано, что существует такая проблема, как большая
         нагрузка на веб-сервера. Как данная проблема решается на серверной
         стороне описано в главе "Серверные фермы и балансировка нагрузки".
         Однако это не единственный подход для повышения эффективности работы
         веб-серверов - улучшением производительности можно заняться и с
         другой стороны - со стороны клиента. На клиентской
         стороне
         лучшая производительность может быть достигнута с применением методов
         кэширования. В частности, кэширующий прокси (веб-прокси) обеспечивает большой
         общий кэш для группы клиентов.</p>
      <h3>Почему недостаточно кэша браузеров? </h3>
      <p>В данной работе вопрос о кэшировании до сих пор обходится стороной. В
         главе "Структура HTTP
         пакета" приводится
         таблица с некоторыми
         методами. Из этой таблицы следует, что браузеры могут кэшировать ответы и использовать их многократно для
         ответов на последующие запросы. Различные поля заголовков и правила используются
         браузером, чтобы определить, является ли кэшированная копия веб-страницы все еще
         актуальной. Кэширование улучшает работу, сокращая продолжительность времени ответа и загруженность сети. Даже если браузер должен запросить сервер о
         подтверждении актуальности
         страницы, продолжительность времени ответа сокращена и сетевая нагрузка меньше,
         особенно для больших страниц, так как посылается только маленькое
         сообщение. Так что лучшее, что может сделать браузер, — кэшировать все веб-страницы,
         которые посетил пользователь. Однако  существует большое количество страниц, которые пользователь посетит только
         один раз. Эти страницы всегда надо получать с сервера. Единственный
         способ использовать кэш более эффективно — сделать его общим
         для нескольких пользователей. Веб-прокси (Web proxy) решает эту задачу.
         Обычно он обеспечивает кэширование веб-ответов, и так как он находится
         в совместном доступе, то имеет существенно больший кэш, чем браузер.</p>
      <h3>Общая схема веб-прокси</h3>
      <p>Каждый браузер
         настроен так, что он отправляет запросы к прокси, а не к реальному серверу страницы.
         Если прокси имеет эту страницу, он возвращает ее немедленно. В противном случае,
         прокси берет страницу с сервера, добавляет ее к кэшу для будущего использования
         и возвращает клиенту то, что он запросил. </p>
      <img src="source/web-proxy.png" alt="" class="img-responsive">
      <div class="alert alert-danger">
         <h3>Недостатки Веб-прокси</h3>
         <p >Общий доступ не может быть сделан для
            зашифрованного трафика, страниц, которые требуют аутентификацию, и некэшируемых
            страниц, которые возвращаются программами.
            Динамические страницы, особенно созданные программами, — это тот
            случай, для которого кэширование не эффективно. Таких страниц в
            ближайшее время будет всё больше и больше.
         </p>
      </div>
   </div>
</div>

<div class="cs-paragraph" id="HTTP">
   <div class="paragraph-header">Общие сведения о HTTP</div>
   <div class="paragraph-body">
      <h2 class="text-center">Общие сведения о HTTP</h2>
      <h3>Кратко об HTTP</h3>
      <p>HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) - простой протокол прикладного уровня, работающий по принципу запрос-ответ,  обычно содержится в пакете TCP. </p>
      <p>Несмотря на свою прикладную природу HTTP всё больше становится больше похож на транспортный протокол, который предоставляет способ передачи контента из одной сети в другую. Эти процессы не всегда идут в рамках общения веб-браузера с веб-сервером. </p>
      <p>Медиаплеер может использовать HTTP, чтобы обратиться к серверу и получить информацию об альбоме. Антивирус может использовать HTTP для того, чтобы загрузить последние обновления. Разработчики — для получения файлов по какому-либо проекту. Бытовая электроника, такая как рамки для цифровых фотографий, часто используют HTTP сервер как интерфейс, связывающий их с внешним миром. Коммуникации между компьютерами все чаще идут при помощи HTTP. В общем HTTP популярен, и скорее всего эта популярность будет сохраняться долгое время.
      </p>
      <h3>Соединения</h3>
      <p>Обычный способ взаимодействия браузера с сервером заключается в установке TCP соединения с портом 80 сервера. Ценность использования TCP в том, что ни браузерам, ни серверам не приходится беспокоиться о том, что делать со слишком длинными сообщениями, надежностью и контролем перегрузки. Все это обеспечивается протоколом TCP. </p>
      <h4>HTTP 1.0</h4>
      <p>Ранее, в HTTP 1.0 после установки соединения посылался один запрос, на который приходил один ответ. После этого TCP-соединение разрывалось. В то время типичная веб-страница целиком состояла из HTML-текста, и такой способ взаимодействия был адекватным. Однако вскоре средняя веб-страница стала изобиловать большим количеством ссылок на различные значки и другие украшения. Очевидно, что установка TCP-соединения для передачи одного значка оказалась нерациональной и слишком дорогой. </p>

      <h4>HTTP 1.1</h4>
      <p>В протокол  HTTP 1.1 была включена поддержка постоянного соединения (persistent connection). Это означало, что появилась возможность установки TCP-соединения, отправки запроса, получения ответа, а затем передачи и приема дополнительных запросов и ответов. Эта стратегия называется повторным использованием соединения (connection reuse). Таким образом, снизились накладные расходы, возникавшие при постоянных установках и разрывах соединения. Стало возможным также конвейеризировать запросы, то есть отправлять запрос 2 еще до прибытия ответа на запрос 1.
      </p>
      <p>
         Разница в производительности между этими тремя случаями показана на рисунке.
      </p>
      <img src="source/connect.png" alt="" class="img-responsive">
      <p>В первой части мы видим три запроса, отсылаемых один за другим, при этом для каждого устанавливается отдельное соединение. Предположим, что это представление страницы с двумя размещенными на ней картинками, находящимися на одном сервере. URL изображений определяется при получении главной страницы, так что они получаются позднее ее. Сегодня на обычной странице присутствует около 40 других объектов, которые должны быть получены для ее отображения. Но это сделает рисунок огромным, так что в примере используется  всего два размещенных объекта.</p>
      <p>В центре рисунка  страница получена при помощи постоянного соединения. То есть TCP-соединение открывается с самого начала, затем посылаются те же самые 3 запроса, как и раньше один за другим, и только после этого соединение закрывается. Такой алгоритм является более производительным.
      </p>
      <p>
         Наконец, в правой части рисунка,  установлено одно постоянное соединение, а запросы передаются конвейеризовано. Второй и третий запросы отсылаются за особенно короткий промежуток времени, так как была получена достаточно большая часть главной страницы, чтобы можно было сделать вывод о том, что изображения должны быть загружены и отображены. В итоге приходят ответы на эти запросы. Этот метод сокращает время, в течение которого сервер не занят делом, так что он и дальше повышает производительность. Основной вопрос данной схемы — это «когда закрывать соединение?» Соединение с сервером не должно разрываться, пока загружается страница. На практике клиенты и серверы обычно сохраняют постоянное соединение, пока не пройдет какого-то небольшого промежутка времени (например, 60 с), в течение которого не будет отослано ни одного запроса и не будет принято ни одного ответа, или же в том случае, если открыто слишком много соединений и некоторые следует закрыть.
      </p>
   </div>
</div>

<div class="cs-paragraph" id='front-end-frameworks'>
   <div class="paragraph-header">Front-end фреймворки</div>
   <div class="paragraph-subheader"></div>
   <div class="paragraph-body">
      <h2 class="text-center">Front-end фреймворки</h2>
      <h3>Лирическое вступление</h3>
      <p>При написании серьезных Веб-приложений возникает несколько серьезных проблем:</p>
      <ul>
         <li>Никая скорость разработки и высокая конкуренция. </li>
         <li>Проблема в виде груды вложенных возвратных функций и разбросанных DOM-элементов без всякой структуры (вместо приложения). Даже человек, писавший все от начала и до конца не разберется с этим: с какого-то момента контролировать все потоки данных становится невозможным. Код превращается в кашу. </li>
         <li>Проблема совместимости различных версий браузера. </li>
      </ul>
      <p>
         Что с этим делают программисты? Они зовут на помощь фреймворки
      </p>
      <hr class="featurette-divider">

      <h3>Полноценные MVC фреймворки</h3>
      <p>
         Эти современные библиотеки дают разработчикам простой путь к организации кода, используя вариации паттерна проектирования, известного как MVC (Model-View-Controller). MVC разделяет задачи в приложении на 3 части: модель, вьюха и контроллер
      </p>
      <h4>Модель</h4>
      <p>
         Модель (логика) представляют проблемно-ориентированные знания и данные в приложении. Думайте о них как о типе данных, которые сможете смоделировать, о таких, как Пользователь, Фото, или Замечание. Модели должны информировать о чём-либо при наблюдении за их текущим состоянием.
      </p>
      <h4>Представление</h4>
      <p>
         Представление (вид) обычно проектируется в виде пользовательского интерфейса, такого как разметка и шаблоны, но не интерактивного. Они должны знать о существовании Моделей, но непосредственно не общаться с ними.
      </p>
      <h4>Контроллер</h4>
      <p>
         Контроллеры (диспетчеры) обрабатывают входные данные (клики, пользовательские действия) в приложении, а Представления можно рассматривать как выходной продукт обработки. Когда Контроллер меняет состояние Модели (например, редактирование заголовка на фото), он прямо не меняет Представление. Это — случай, где работают отношения Модели и Представления.
      </p>
      <div class="alert alert-danger">
         <p>
            MVC-фреймворки на Javascript, помогающие в структурировании кода, не всегда строго следуют описанному образцу. У некоторых Контроллер будет отвечать за Представление (backbone.js), самоуверенно смешивая компоненты, считая, что так пока будет лучше.
         </p>
      </div>

      <h3>Наиболее популярные mvc-фреймворки:
      </h3>
      <ul>
         <li>Backbone.js</li>
         <li>Ember.js</li>
         <li>AngularJS</li>
         <li>Spine.js</li>
         <li>KnockoutJS</li>
         <li>Dojo</li>
         <li>YUI</li>
         <li>Batman.js</li>
         <li>Closure</li>
         <li>Agility.js</li>
         <li>Knockback.js</li>

      </ul>

      <hr class="featurette-divider">

      <h2>CSS-фреймворки</h2>
      <h3>Что такое CSS фреймворк?</h3>
      <p>
         CSS-фреймворк — фреймворк, созданный для упрощения работы верстальщика, быстроты разработки и исключения максимально возможного числа ошибок вёрстки.
      </p>
      <h3>Что дает css-фреймворк?</h3>
      <ul>
         <li>Позволяет не искушенному в тонкостях вёрстки программисту или дизайнеру правильно создать HTML-макет.</li>
         <li>Вёрстка на базе слоёв, а не таблиц.</li>
         <li>Более быстрая разработка.</li>
         <li>Кроссбраузерность.</li>
         <li>Единообразие кода при работе в команде позволяет снизить число разногласий при разработке.</li>

      </ul>
      <div class="alert alert-danger">
         <p>
            Недостаток всех css-фреймворка - зависимость дизайна от css-библиотеки.
         </p>
      </div>
      <h3>Наиболее популярные css-фреймворки:</h3>
      <ul>
         <li>Bootstrap</li>
         <li>Maxmertkit </li>
         <li>Twitter Flight </li>
         <li>Blueprint</li>
         <li>960 Grid System</li>
         <li>Yet Another Multicolumn Layout (YAML)Bluetrip</li>
      </ul>

   </div>
</div>

<div class="cs-paragraph" id='cl-srv-architecture'>
   <div class="paragraph-header">Клиент-серверная архитектура</div>
   <div class="paragraph-body">
      <h2 class="text-center">Понятие о клиент-серверной архитектуре
         Веб-приложений</h2>

      <h3>WEB 1.0</h3>
      <p class="">
         До некоторых пор (в основном до появления ajax) сайты представляли собой набор страничек, который генерировался веб-сервером, подключенным к базе данных. При каждой отправке данных на сервер, наш сервер “выплевывал” html страницу,  старая страница при этом уходила проч.
      </p>

      <hr class="featurette-divider">

      <h3>WEB 2.0</h3>
      <p class="">
         Современные Веб-приложения работают иначе, и всё чаще представляют собой одну страницу, на которую динамически подгружаются данные, генерируемые сервером. Решает эту задачу технология под названием  AJAX (Asynchronous JavaScript and XML — асинхронный JavaScript и XML).
      </p>
      <p class="">
         Теперь Веб-приложения состоят из двух частей: серверной (back-end) и клиентской (front-end).  Эти программы сильно отличаются друг от друга, и обычно пишутся разными группами людей. Части общаются между собой посредством API.
      </p>

      <hr class="featurette-divider">

      <h3>Как сервер взаимодействует с клиентом?</h3>
      <p>
         Представим себе сервис, работающий с картами, который позволяет пользователю ввести название улицы, после чего предоставляет ему карту местности. Получив запрос, веб-сервер должен использовать программу для создания страницы, которая показывает карту запрашиваемой местности из базы данных улиц и другой географической информации.
      </p>
      <p>
         Это действие показано как шаги 1–3. Запрос (шаг 1) вызывает запуск программы на сервере. Программа опрашивает базу данных и генерирует нужную страницу (шаг 2) и возвращает ее в браузер (шаг 3).
      </p>
      <img src="source/cl-srv.png" alt="" class="img-responsive">
      <p>
         Возвращаемая страница сама может содержать программы, которые запускаются в браузере. В нашем примере программа позволяет пользователю находить маршруты и исследовать прилежащие области с разными уровнями детализации. Она обновляет страницу, увеличивая или уменьшая масштаб в соответствии с запросами пользователя (шаг 4). Чтобы провести некоторые операции, программе может понадобиться больше данных с сервера. В этом случае программа отошлет запрос на сервер (шаг 5), который отыщет нужную информацию в базе данных (шаг 6) и вернет ответ (шаг 7). Затем программа продолжит вносить изменения на страницу (шаг 4).
      </p>
      <hr class="featurette-divider">

      <div class="row">
         <h3>Итог:</h3>
         <div class="col-lg-6 col-md-6 text-center ">
            <h3>Back-end</h3>
            <p class="">
               Серверная программа отвечает за обработку, хранение данных, за вычисления, за ответы на запросы клиентской программы. Она же отвечает на запросы через веб-сервер - программу, являющуюся узлом между сетью и back-end приложением.
            </p>
         </div>
         <div class="col-lg-6 col-md-6 text-center">
            <h3>Front-end</h3>
            <p class="">
               Клиентская программа отвечает за пользовательский
               интерфейс и
               взаимодействие с северной частью. Она отслеживает пользовательские действия, шлет запросы, получает ответы и  отображает в удобным для пользователя виде.
            </p>
         </div>
      </div>

   </div>
</div>

<div class="cs-paragraph" id='web-standarts'>
   <div class="paragraph-header">Стандарты веб-технологий</div>
   <div class="paragraph-subheader"></div>
   <div class="paragraph-body">
      <h2 class="text-center">Стандарты Веб-технологий</h2>
      <h3>
         Что такое веб-стандарты
      </h3>
      <p>Веб-стандарты, как следует из их названия, являются стандартами в области веб-технологий. Эти стандарты являются рекомендациями для разработчиков программного обеспечения и для веб-мастеров. Служат веб-стандарты для того, чтобы, с одной стороны, пользователи ПО без проблем и неудобств могли пользоваться сетью интернет, а с другой стороны, для того, чтобы разработчики программного обеспечения или веб-мастера были уверены в работоспособности своих продуктов.
      </p>

      <h3>
         Немного о войнах браузеров
      </h3>
      <p>
         Исторически сложилось так, что в начале 90-х годов XX века развязалась так называемая "война браузеров" между компанией Netscape и Microsoft. Суть войны заключалась в том, что разработчики веб-браузеров стремились привнести в продукты своих разработок собственные новые функции, но при этом совершенно не заботились о совместимости технологий и не согласовывали свои действия с разработчиками конкурирующей компании. По этой причине начало возрастать недовольство как среди людей, создающих сайты, так и среди людей, пользующихся сетью интернет - ведь сайты, которые были написаны специально для Netscape Navigator крайне плохо работали в Microsoft Intrnet Explorer и наоборот посредством Internet Explorer почти невозможно было просматривать сайт, написанный для Netscape Navigator.
      </p>

      <h3>
         World Wide Web Consortcium
      </h3>
      <p>
         В 1994 году в Массачусетском технологическом институте при поддержке CERN, DARPA и Европейской Комиссии появилась организация World Wide Web Consortcium или, сокращенно, W3C. Целью консорциума по сей день является упорядочивание всех веб-технологий для того, чтобы обеспечить их доступность как можно большему числу людей всего мира.
      </p>
      <p>Начиная, примерно, с 2000 года все крупные производители программного обеспечения для сети интернет стараются придерживаться стандартов W3C для того, чтобы обеспечить своим продуктам максимальную эффективность и совместимость с большинством веб-ресурсов. Результат работы консорциума по стандартизации веб-технологий на сегодняшний день очень значителен и выражается в том, что веб-технологии получают все большее распространение в нашем мире и упрощают многим жизнь.</p>
   </div>
</div>

<div class="cs-paragraph" id="html">
   <div class="paragraph-header">HTML</div>
   <div class="paragraph-subheader"></div>
   <div class="paragraph-body">

      <h2 class="text-center">HTML</h2>
      <div class=''>
         <h3>Об HTML 'в двух словах'</h3>
         <p>Вообще говоря HTML(от англ. HyperText Markup Language — «язык
            гипертекстовой разметки») - это язык разметки
            документов (Как например XML или Markdown ).
            C помощью HTML можно размещать на веб-страницах текст,
            графику, видео, а также указатели на другие страницы и т. п.
            Языки разметки содержат подробные команды форматирования. Например, в языке HTML команда &lt;b&gt; означает начало участка текста, печатаемого полужирным шрифтом, а &lt;/b&gt; означает конец такого участка.</p>
      </div>

      <hr class="featurette-divider">

      <div>
         <h3>История развития:</h3>
         <p>
            HTML 1.0 относится к версии HTML, которая использовалась при возникновении Всемирной паутины. Версии 2.0, 3.0 и 4.0 сменяли друг друга достаточно быстро в течение нескольких лет после того, как Всемирная паутина обрела популярность. После HTML 4.0 прошло почти десять лет, прежде чем путь для новой версии, HTML 5.0, был открыт. Так как данный стандарт является основным обновлением, объединяющим способы, которыми браузеры обрабатывают разнообразный контент, HTML 5.0 до сих пор находится в стадии разработки. Тем не менее основные браузеры уже поддерживают возможности HTML 5.
         </p>
         <p>
            Изменения, вносимые в версии HTML, связаны с добавлением новых возможностей, которые люди хотели бы видеть, но пока они не вошли в стандарт, использовать данные возможности приходится нестандартным образом (например, при помощи плагинов). Так, например, в первых двух версиях не существовало таблиц, они были добавлены только в HTML 3.0. HTML-таблица состоит из нескольких строк, каждая из которых состоит из нескольких ячеек, которые могут содержать широкий спектр данных (например, текст, изображения и даже другие таблицы).
         </p>
         <p>
            До введения HTML 3.0 авторам, которым нужна была таблица, приходилось прибегать к особым методам, таким как включение картинки, на которой изображалась таблица.
         </p>
      </div>

      <hr class="featurette-divider">

      <div class="row">
         <div class="col-lg-6 col-md-6 text-center">
            <h3>HTML 4</h3>
            <p>
               HTML 4.0 отличается от предыдущих версий некоторыми новыми свойствами. Они включают в себя специальные методы доступа для людей с ограниченными возможностями, внедрение объектов (обобщение тега &lt;img&gt;, позволившее включать в состав страниц не только изображения, но и другие объекты), поддержка языков написания сценариев (скриптов), что дало толчок к развитию динамических страниц и т. д.
            </p>
         </div>
         <div class="col-lg-6 col-md-6 text-center">
            <h3>HTML 5</h3>
            <p>
               HTML 5.0 включает множество опций, предназначенных для обработки мультимедиа, которое на сегодняшний день широко используется во Всемирной паутине. Видео и аудио может размещаться на страницах и проигрываться браузером, и это не потребует от пользователя установки плагинов. Вместо использования растровых форматов графических объектов (таких как JPEG и GIF), можно строить рисунки в браузере в виде векторной графики. Также расширились возможности поддержки выполнения скриптов в браузерах, таких как фоновые потоки вычислений и доступ к хранилищу. Все эти возможности помогают поддерживать веб-страницы, которые больше похожи на традиционные приложения с пользовательским интерфейсом, чем на документы.
            </p>
         </div>
      </div>

      <hr class="featurette-divider">

      <table class="table text-center">
         <thead>
         <tr>
            <td>Объект</td>
            <td>HTML 1</td>
            <td>HTML 2</td>
            <td>HTML 3</td>
            <td>HTML 4</td>
            <td>HTML 5</td>
         </tr>
         </thead>
         <tbody>
         <tr>
            <td class="text-left">Гиперссылки</td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Изображения</td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Списки</td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Активные карты и изображения</td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Формы</td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Математические формы</td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Панели инструментов</td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Таблицы</td>
            <td></td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Возможености по обеспечению доступности</td>
            <td></td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Встраивание объектов</td>
            <td></td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Таблицы стилей</td>
            <td></td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Скрипты</td>
            <td></td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Видео и аудио</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Электронная графика</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Отображение XML</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Фоновые потоки</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Хранение информации в браузере</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         <tr>
            <td class="text-left">Область рисования</td>
            <td></td>
            <td></td>
            <td></td>
            <td></td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
         </tr>
         </tbody>
      </table>

      <hr class="featurette-divider">

      <div>
         <h3>О главном</h3>
         <p>
            Страница состоит из заголовка и тела. Вся страница размещается между командами форматирования, называемыми в языке HTML тегами (tags), &lt;html&gt; и &lt;/html&gt;. Впрочем, большинство браузеров правильно отобразят страницу и в отсутствие этих тегов. Заголовок веб-страницы заключен в скобки тегов &lt;head&gt; и &lt;/head&gt;, а тело располагается между тегами &lt;body&gt; и &lt;/body&gt;.  Команды внутри тегов называют директивами (directives). Регистр символов в тегах не имеет значения. Например, &lt;head&gt; и &lt;HEAD&gt; означают одно и то же, однако у нижнего регистра лучше характеристики совместимости. Программы обработки HTML-текстов игнорируют лишние пробелы и переносы строк, так как они все равно форматируют текст так, чтобы он помещался в заданной области отображения. Соответственно, для того чтобы исходные HTML-документы легче читались, в них можно добавлять произвольное количество знаков табуляции, пробелов и символов переноса строк. И наоборот, для разделения абзацев в тексте в исходный HTML-текст недостаточно вставить пустую строку, так как она просто игнорируется браузером.
         </p>
      </div>
      <div>
         <h3>Атрибуты</h3>
         <p>
            Некоторые теги могут иметь именованные параметры, называемые атрибутами (attributes). Например, тег &lt;img&gt; используется для того, чтобы наравне с текстом расположить на странице изображение. У этого тега есть два атрибута src и alt. Первый атрибут предоставляет URL для изображения. HTML-стандарт не определяет, какие форматы изображений разрешены. Для каждого тега стандарт HTML устанавливает список допустимых атрибутов и их значение.
         </p>
      </div>
      <div>
         <h3>Заголовки</h3>
         <p>
            Каждый из заголовков создается при помощи тега вида &lt;hn&gt;, где n — цифра от 1 до 6. &lt;h1&gt; является самым важным заголовком, &lt;h6&gt; — наименее важным. Как это отобразить на экране, зависит от браузера. Обычно заголовки с меньшими номерами отображаются более крупными шрифтами. Браузер может также выделять различные заголовки различными цветами. Обычно заголовки &lt;h1&gt; выводятся на экран крупным полужирным шрифтом и выделяются, по меньшей мере, одной пустой строкой над и под заголовком. В отличие от них заголовки &lt;h2&gt; отображаются шрифтом меньшего размера, отступы перед заголовком и после него также уменьшаются.
         </p>
         <h1>Заголовок h1</h1>
         <h2>Заголовок h2</h2>
         <h3>Заголовок h3</h3>
         <h4>Заголовок h4</h4>
         <h5>Заголовок h5</h5>
         <h6>Заголовок h6</h6>
      </div>
      <div>
         <h3>Абзацы</h3>
         <p>
            Тегом &lt;p&gt; отмечается начало абзаца. Браузер может это отобразить, например, добавив пустую строку и отступ.
         </p>
      </div>

   </div>
</div>

<div class="cs-paragraph" id='css'>
   <div class="paragraph-header">CSS</div>
   <div class="paragraph-subheader"></div>
   <div class="paragraph-body">
      <h2 class="text-center">
         CSS
      </h2>
      <h3>Что такое CSS</h3>
      <p>CSS (Cascading Sryle Sheets — каскадные таблицы стилей) ввели таблицы
         стилей во Всемирную паутину с появлением HTML 4, однако они стали широко использоваться и поддерживаться в браузерах только в 2000 году.
      </p>
      <p>
         CSS определяет простой язык для описания правил, которым подчиняется внешний вид размеченного тегами контента. CSS делает страницы красивыми  и дает возможность нарисовать всё, что вы пожелаете.
      </p>
      <hr class="featurette-divider">
      <h3>
         Как хранятся таблицы стилей?
      </h3>
      <p>
         Таблицы стилей можно поместить в файл HTML (например, используя тег &lt;style&gt;), но обычно они хранятся в отдельном файле, на который дается ссылка. Например, тег &lt;head&gt; страницы AWI можно изменить так, чтобы она считывала информацию о каскадном стиле из файла
      </p>
      <h4>
         Пример хранения в виде файла <code>*.css</code>
      </h4>

      <p><code>.cs-navbar</code><p>
      <p><code>   {</code><p>
      <p><code>      margin-top: 20px;</code><p>
      <p><code>      position: absolute</code><p>
      <p><code>      top: 0;</code><p>
      <p><code>      right: 0;</code><p>
      <p><code>      left: 0;</code><p>
      <p><code>   }</code><p>
      <h4>
         Пример хранения в HTML странице в теге <code>&lt;style&gt;</code>
      </h4>
      <p><code>&lt;style&gt;</code></p>
      <p><code>   body { </code></p>
      <p><code>      color: red;</code></p>
      <p><code>   }</code></p>
      <p><code>&lt;/style&gt;</code></p>
      <h4>
         Пример хранения в HTML странице внутри тега, для которого она
         предназначена
      </h4>
      <p>
         <code>&lt;p style="font-size: 20px; color: green; font-family: arial, helvetica, sans-serif"&gt;</code>
      </p>
      <hr class="featurette-divider">
      <h3>
         Преимущества хранения стилей в отдельном файле:
      </h3>
      <div class="row">
         <div class="col-lg-6 col-md-6">
            <p class="text-center">
               Позволяет применить один набор стилей к нескольким страницам веб-сайта. Таким образом мы получаем единообразный внешний вид страниц, даже если они разрабатывались разными авторами в разное время, кроме того, мы можем изменить внешний вид всего сайта, отредактировав только файл CSS, а не все файлы HTML. Этот метод можно сравнить с подключением файла заголовка директивой #include в программе на языке C.
            </p>
         </div>
         <div class="col-lg-6 col-md-6">
            <p class="text-center">
               Ещё одно преимущество заключается в том, что загружаемые файлы HTML оказываются гораздо менее громоздкими, так как браузер может загрузить одну копию файла CSS для всех страниц, которые на нее ссылаются. Ему не нужно загружать новые копии всех определений для каждой отдельной веб-страницы.
            </p>
         </div>
      </div>
   </div>
</div>

<div class="cs-paragraph" id='back-end-frameworks'>
   <div class="paragraph-header">Back-end и фреймворки
   </div>
   <div class="paragraph-subheader"></div>
   <div class="paragraph-body">
      <h2 class="text-center">
         Back-end и фреймворки
      </h2>
      <h3>На чем писать серверное приложение?</h3>
      <p>Итак, ранее было сказано, что Веб-приложения состоят из двух взаимодействующих меж собой частей - front-end и back-end. Язык, на котором обрабатываются данные на уровне клиента - это язык, который понимает ваш браузер - JavaScript. На каком же языке работает back-end? На любом языке, который понимает компьютер (в качестве этого языка может использоваться даже JavaScript).

      </p>
      <p>
         Наиболее известные языки на уровне сервера - PHP (“На нем пол интернета написано”, - фраза, которую часто слышишь от веб программистов. Правда они же утверждают, что это самый худший язык веба. ), С#, Java, Ruby, Python, JavaScript.
      </p>
      <hr class="featurette-divider">
      <h3>
         back-end фреймворки
      </h3>
      <p>
         Сами понимаете, что писать на голом языке программу, являющуюся веб-приложением медленно и неэффективно. Кроме того, в какой-то момент программа станет настолько большой и сложной, что её трудно будет контролировать. Поэтому, как и в клиентских приложениях, серверные используют фреймворки.
      </p>
      <div class="alert alert-danger">
         <p>Изучение серверных фреймворков является далеко не тревиальной задачей, зачастую хорошо освоить фреймворк труднее, чем освоить основы языка программирования, на котором он написан. </p>
      </div>
      <p>Следует отметить, что фремворки большое внимание уделяют информационной безопасности, что несомненно является плюсом. У каждого языка обычно несколько фреймворков. Приведем несколько наиболее известных:</p>
      <ul>
         <li>Zend (PHP)</li>
         <li>Yii (PHP)</li>
         <li>ASP.NET MVC </li>
         <li>Django (Python)</li>
         <li>Spirng (Java)</li>
         <li>Ruby on Rails (Ruby)</li>
         <li>Sinatra (Ruby)</li>
      </ul>
      <hr class="featurette-divider">
      <h3>Общие сведения о серверных фреймворках на примере Ruby on Rails</h3>
      <p>Поскольку все фреймворки описать не представляется возможным дадим представление о работе серверных фреймворках на примере  Ruby on Rails (RoR).</p>
      <img src="source/ruby-rails.jpg" alt="" class="img-responsive">
      <p>Как и многие другие, RoR имеет MVC архитектуру, позволяющую отделить мух от котлет. В стандартном шаблоне фреймворка находится около </p>
      <h4>Модель</h4>
      <p>Модель предоставляет остальным компонентам приложения объектно-ориентированное отображение данных (таких как каталог продуктов или список заказов). Объекты модели могут осуществлять загрузку и сохранение данных в реляционной базе данных, а также реализуют бизнес-логику.</p>
      <h4>Представление</h4>
      <p>
         Представление создает пользовательский интерфейс с использованием полученных от контроллера данных. Представление также передает запросы пользователя на манипуляцию данными в контроллер (как правило, представление не изменяет непосредственно модель). Представление в больших приложениях, имеющих клиентскую часть, это страничка в формате JSON/XML, а не HTML. Используя данные с этой страницы клиентская программа генерирует HTML в браузере.
      </p>
      <h4>Контроллер</h4>
      <p>Контроллер в Rails — это набор логики, запускаемой после получения HTTP-запроса сервером. Контроллер отвечает за вызов методов модели и запускает формирование представления.
      </p>
      <h4>Маршрутизация</h4>
      <p>Соответствие интернет-адреса с действием контроллера (маршрут) задается в файле <code>config/routes.rb</code>.Там же задается тип запроса.
      </p>
      <h4>Схема взаимодействия компонентов MVC</h4>
      <img src="source/MVC_schem.png" alt="" class="img-responsive">
      <div class="">
         <h3>Простой пример</h3>
         <p>
            Представим, что существует некоторое приложение, хранящее статьи в интернете. Для простоты назовем статьи контентом. Представим также, что статьи должны выдаваться по адресу <code>имя_вашего_сервера/home/index.json</code> В этом виде их подхватывает клиентское приложение и красиво отображает пользователю
         </p>
         <h4>Пример маршрута</h4>
         <p>
            В простейшем приложении <code>config/routes.rb</code> может выглядеть так:
         </p>
      <pre>
         <code>
            Rails.application.routes.draw do
            get 'home/index'

            root 'home#index'

            end
         </code>
      </pre>
         <p>
            В первой строчке get - тип запроса страницы <code>index</code>, home - имя контроллера, index - имя вьюхи.
         </p>
         <h4>Пример контроллера</h4>
         <p>
            В файле <code>app/controllers/home_controller.rb</code> находится контроллер, который в методе <code>index</code> собирает в переменную класса home под названием <code>content</code> весь контент из модели Content. Во вьюхе, привязанной к контроллеру эта переменная становится автоматически доступна. <code>respond_to :json</code> означает, что сервер выплевывает вьюху в формате JSON (не HTML!)
         </p>
      <pre>
         <code>
            class HomeController &lt; ApplicationController
            respond_to :json
            def index
            @content = Content.all
            end
            end
         </code>
      </pre>
         <h4>Пример представления</h4>
         <p>
            Соответственно в файле <code>app/views/home/index.json.jbuilder</code> должна находиться вьюха, в которой должно лежать что-то вроде этого:
         </p>
         <code>json.contents @content</code>
         <h4>Из чего состоит наш контент и откуда мы его берем?</h4>
         <p>
            Контент хранится в базе данных, подключенной к RoR через специальный интерфейс <code>Active Record</code>. Для создания таблицы необходимо сгенерировать файл с содержимым, которое нам необходимо хранить в <code>Content</code>. В этом файле также необходимо указать все атрибуты модели и их тип. К примеру можно создать атрибуты рейтинга статьи, заголовка и тела. Дата и время записи создадутся автоматически. При таких атрибутах файл миграции может выглядеть вот так:
         </p>
      <pre>
         <code>
            class CreateArticles &lt; ActiveRecord::Migration
            def change
            create_table :contents do |t|
            t.string :title
            t.text :body

            t.timestamps null: false
            end
            end
            end
         </code>
      </pre>

      </div>


   </div>
</div>

<div class="cs-paragraph" id="javascript">
   <div class="paragraph-header">JavaScript</div>
   <div class="paragraph-subheader"></div>
   <div class="paragraph-body">
      <h2 class="text-center">JavaScript</h2>
      <div class="">
         <h2>Краткая характеристика</h2>
         <ul class="lead">
            <li>С-синтаксис</li>
            <li>Нестрогая типизация</li>
            <li>Прототипно-ориентированный</li>
            <li>Сценарный</li>
            <li>Используется не только в браузерах</li>
            <li>Самый популярный язык программирования в мире</li>
         </ul>
      </div>

      <hr class="featurette-divider">

      <h2 class="">История создания</h2>
      <div class="row">
         <div class="col-lg-8 ">
            <p class="">
               Во времена великих войн браузеров компания Netscape наняла некоего Брендана Эйха на должность разработчика, поставив перед ним задачу внедрения аналога Лиспа в свой продукт. Техническое задание было весьма размытым и не очевидным (язык должен был управлять HTML, java-аплетами, изображениями и т.д. ). Язык был написан Эйхом за 10 дней, и первоначально имел название Mocha(это не шутка). Позднее, после нескольких переименований, язык назвали JavaScript, поскольку в те времена язык Java был очень популярен, и считался эталонным. Собственно название до сих пор принадлежит Oracle.
            </p>
            <p>
               По инициативе компании Netscape была проведена стандартизация языка ассоциацией ECMA. Разработка первой редакции спецификации началась в ноябре 1996 года.
            </p>
         </div>
         <div class="col-lg-4">
            <img class="img-responsive" src="source/BEich.jpg">
            <p class="text-right ">Брендан Эйх</p>
         </div>
      </div>


      <hr class="featurette-divider">
      <h2 class="">
         Анализ JavaScript
      </h2>
      <div class="row">
         <div class="col-md-4 col-lg-4">
            <p class="">
               JavaScript - язык, в основе которого лежат как хорошие, так и плохие вещи (порой, даже очень плохие). Хорошие вещи связаны с применением функций, нестрогой типизацией и динамическими объектами. Плохие вещи - модель программирования на основе глобальных переменных, странный синтаксис наследования, множество особенностей, которые надо просто “знать”.
            </p>
         </div>
         <div class="col-md-4 col-lg-4 ">
            <p class="">
               Почти всё в JavaScript представляет собой объекты: функция - это объект, массив - тоже объект, ну и конечно объект - это тоже объект.  При этом объекты создаются простым указанием их компонентов, и не нуждаются в классах(хотя JavaScript позволяет создавать объекты на основе классов). Это может показаться безумием для программистов с классическим образованием, но при правильном использовании это очень удобно.
            </p>
         </div>
         <div class="col-md-4 col-lg-4 ">
            <p class="">
               Поскольку почти всё в JavaScript это объект, то функции, к примеру, могут содержать в себе другие функции, массивы и другие объекты. При этом для создания нового объекта используется прототип - объект, от которого необходимо провести наследование.
            </p>
         </div>
      </div>


      <hr class="featurette-divider">
      <div class="alert alert-success ">
         <h2>
            Что умеет JavaScript
         </h2>
         <p>
            Современный JavaScript — это «безопасный» язык программирования общего назначения. Он не предоставляет низкоуровневых средств работы с памятью, процессором, так как изначально был ориентирован на браузеры, в которых это не требуется. Однако на нем можно быстро писать серьезные приложения, сосредотачивая внимание на самих алгоритмах, а не на синтаксисе.
            В браузере JavaScript умеет делать всё, что относится к манипуляции со страницей, взаимодействию с посетителем и, в какой-то мере, с сервером:

         </p>
         <ul>
            <li>Реагировать на действия посетителя, обрабатывать клики мыши, перемещения курсора, нажатия на клавиатуру и т.п.</li>
            <li>Посылать запросы на сервер и загружать данные без перезагрузки страницы (эта технология называется "AJAX").</li>
            <li>Получать и устанавливать cookie, запрашивать данные, выводить сообщения</li>
            <li>И многое, многое другое!</li>
         </ul>
      </div>

      <div class="alert alert-danger ">
         <h2>
            Плохие вещи
         </h2>
         <p>
            В книге Дугласа Крокфорда под названием  “JavaScript - сильные стороны”, под главы “Кошмарные вещи” и “Плохие вещи” отводится 16 страниц, в то время, как в глава “Прекрасные черты” содержит всего 3 страницы текста. Сам Крокфорд - эксперт в JavaScript, один из его самых ярых защитников, а также основатель формата JSON. Понимаете, о чем я?
         </p>
      </div>
      <h3>Несколько странностей, которыми обычно пугают новичков:</h3>
      <ul>
         <li>NaN является числом<p>Специальное значение NaN(«Not a Number» — не число) является числом!</p>
            <p><code>typeof NaN == 'number' //true</code></p></li>
         <li>Операторы <code>>=</code> и <code>==</code> по-разному интерпретируют null         <p><code>null > 0 //false</code></p>
            <p><code>null == 0 //false</code></p>
            <p><code>null >= 0 //true</code></p></li>

         <li> 0.1 + 0.2 не равно 0.3 <p><code> 0.1 + 0. 2 //0.30000000000000004</code></p></li>
      </ul>
   </div>
</div>

<div class="cs-paragraph" id='web-srv'>
   <div class="paragraph-header">Принципы работы Веб-серверов</div>
   <div class="paragraph-subheader"></div>
   <div class="paragraph-body">
      <h2 class="text-center">Принципы работы Веб-серверов</h2>
      <h3>Что такое Веб-сервер</h3>
      <p>
         Веб-сервер — сервер, принимающий HTTP-запросы от клиентов, обычно веб-браузеров, и выдающий им HTTP-ответы, как правило, вместе с HTML-страницей, изображением, файлом, медиа-потоком или другими данными.
      </p>
      <h3>
         Алгоритм работы
      </h3>
      <p>
         Общий алгоритм работы веб-сервера можно представить следующим образом (зеленым цветом помечены действия, которые обрабатываются веб-сервером)
      </p>
      <img src="source/web-srv.jpg" alt="" class="img-responsive">
      <p>
         После того, как пользователь обратился к определенному ресурсу по протоколу HTTP, клиент (обычно браузер) формирует HTTP-запрос к веб-серверу. Обычно указывается символическое имя сервера (например, "http://www.microsoft.com") – в этом случае браузер предварительно преобразует это имя в IP-адрес при помощи сервисов DNS. После этого по протоколу HTTP на веб-сервер отправляется сформированное HTTP-сообщение. В этом сообщении браузер указывает какой ресурс необходимо загрузить и всю дополнительную информацию. Задача веб-сервера – прослушивать определенный TCP-порт (обычно порт 80) и принимать все входящие HTTP-сообщения.
      </p>
      <h3>Статические страницы</h3>
      <p>
         В простейшем случае при поступлении HTTP-запроса веб-сервер должен считать содержимое запрашиваемого файла с жесткого диска, упаковать его содержимое в HTTP-ответ и отправить клиенту. В случае если требуемый файл не найден на жестком диске, то веб-сервер сгенерирует ошибку с указанием статусного кода 404 и отправит это сообщение клиенту. Такой вариант работы веб-сервера принято называть статическими сайтами. В этом случае на стороне сервера не запускается никакой программный код, кроме программного кода самого веб-сервера.
      </p>
      <p>
         Такой сервер можно изготовить что называется “своими руками”.  В интернете можно найти пример такого сервера практически на любом языке, в котором присутствует функционал работы с сокетами.
      </p>
      <h3>Динамические страницы</h3>
      <p>
         На сегодняшний день в интернете распространены более сложные алгоритмы работы веб-серверов. В общем случае на смену статическим сайтам приходят  полноценные веб-приложения. Отличие таких приложений состоит в том, что HTML-документы и другие ресурсы не хранятся на сервере в виде неизменяемых данных.
      </p>
      <p>
         Вместо этого, на сервере хранится программный код, который способен сгенерировать эти данные в момент обработки запроса. Разумеется, некоторые ресурсы (такие как файлы каскадных стилей, изображения и т.д.) могут храниться как статическое содержимое, но основные страницы HTML генерируют в процессе обработки. В таком случае веб-сервер при обработке запроса HTTP должен обращаться к программному коду, который должен сгенерировать содержимое. С учетом вышесказанного алгоритм работы веб-сервера будет выглядеть следующим образом.
      </p>
      <img src="source/web-srv2.jpg" alt="" class="img-responsive">
      <p>
         Следует отметить, что под выполнением программного кода можно понимать две вещи:
      </p>
      <ul>
         <li>Выполнение скриптов, которые запускаются непосредственно веб-сервером</li>
         <li>Парсинг (обработка данных и приведение их в какой-то формат) запроса и его передача стороннему приложению через интерфейс взаимодействия. В некоторых приложениях реализуется более сложная схема, когда имеется два веб-сервера - первый слушает порт и передает запросы в обработанном виде во второй, второй сервер запускает отдельный процесс для каждого из соединений. </li>
      </ul>
      <h3>Проблема множества клиентов</h3>
      <p>
         Сегодня на средненький сайт обращается около ста пользователей в секунду. Для того, чтобы обработать такое количество запросов веб-серверу (будь то демон, в случае линуксовых серверов, или служба, в случае серверов Windows) необходимо использовать потоки(threds) или дочерние процессы(prefork).
      </p>
      <div class="row">
         <div class="col-md-6 col-lg-6">
            <h3>
               Процессы
            </h3>
            <p>
               CGI (Common Gateway Interface) – наиболее ранний способ взаимодействия веб-сервера и веб-приложения. Основная идея, которая лежит в основе CGI заключается в том, что при поступлении очередного HTTP-запроса, веб-сервер инициирует создание нового процесса и передает ему все необходимые данные HTTP-запроса. После того, как этот процесс отработает, он завершается, передав при этом результат обратно веб-серверу. Поскольку веб-сервер и приложение – это разные процессы с точки зрения операционной системы, то для обмена информации между ними используются средства межпроцессного взаимодействия (IPC) – зачастую это переменные окружения, именованные каналы и т.д. Основным преимуществом CGI является то, что процесс веб-сервера и приложения изолированы друг от друга и в случае неполадок в веб-приложении, завершится с ошибкой именно процесс приложения, при этом процесс самого веб-сервера будет продолжать функционировать.
            </p>

         </div>

         <div class="col-md-6 col-lg-6">
            <h3>
               Потоки
            </h3>
            <p>
               ISAPI (Internet Server API) – альтернативный способ взаимодействия веб-сервера и веб-приложения. В отличии от CGI, при взаимодействии в рамках интерфейса ISAPI, при поступлении очередного запроса, веб-сервер инициирует создание нового потока в рамках основного процесса, в котором работает веб-сервер. Поскольку с точки зрения операционной системы создание потока – это менее дорогостоящая операция, чем создание процесса, то такие приложения на практике оказываются более масштабируемыми. Кроме того, упрощается взаимодействие веб-сервера и веб-приложения, поскольку в этом случае используется единое адресное пространство в рамках операционной системы (поскольку весь код работает в одном и том же процессе).
            </p>

         </div>
      </div>

      <div class="row">
         <div class="col-md-6 col-lg-6">
            <h3>Проблемы процессов</h3>
            <p>
               Необходимость создания каждый раз нового процесса влечет за
               собой дополнительные накладные расходы насоздание процесса (создание процесса – дорогостоящая операция с точки зрения операционной системы) и передачи данных через границы процессов. Этот факт является серьезным недостатком и оказывает существенное влияние на масштабируемость веб-приложения (возможность обрабатывать большее количество поступающих запросов).
            </p>
         </div>

         <div class="col-md-6 col-lg-6">
            <h3>Проблемы потоков</h3>
            <p>
               В случае серьезных неполадок в веб-приложении, которое
               взаимодействует с веб-сервером в рамках ISAPI, веб-сервер также потенциально подвергается риску быть завершенным. Поскольку веб-сервер и веб-приложение работают в одном и том же процессе, это действительно так. Другими словами, прекращение работы процесса с несколькими потоками убьет все потоки. Кроме того потоки неудобны для программиста, поскольку при их использовании необходимо очень аккуратно писать код. Это связано с общими переменными всех потоков. Ещё одна проблема - ограничение использования сторонних библиотек.
            </p>
         </div>
      </div>
   </div>
</div>

<div class="cs-paragraph" id='modern-web-srv'>
   <div class="paragraph-header">Современные веб-серверы</div>
   <div class="paragraph-subheader"></div>
   <div class="paragraph-body">
      <h2 class="text-center">Современные Веб-серверы</h2>
      <h3>Наиболее известные веб-серверы:</h3>
      <ul>
         <li> Apache HTTP Server</li>
         <li> Tomcat</li>
         <li> Internet Information Services</li>
         <li> Jetty</li>
         <li> nginx</li>
         <li> lighttpd</li>
         <li> NodeJS</li>
         <li> Tornado</li>
      </ul>
      <h3>Сравнительная таблица веб-серверов</h3>
      <table class="table table-bordered">
         <thead>
         <tr>
            <td>Название</td>
            <td>Автор и год создания</td>
            <td>Open Source?</td>
            <td>Особенности</td>
         </tr>
         </thead>
         <tbody class="text-center">
         <tr>
            <td>Apache HTTP Server</td>
            <td>Apache Software Foundation, 1995</td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td>Упор на надёжность и гибкость.</td>
         </tr>

         <tr>
            <td>Tomcat</td>
            <td>Sun Microsystems, Apache Software Foundation, 1999</td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td>Реализован полностью на Java.</td>
         </tr>
         <tr>
            <td>Internet Information Services</td>
            <td>Microsoft, 1995</td>
            <td><span class='glyphicon glyphicon-remove'></span></td>
            <td>Является частью пакета IIS. Поддерживает .NET</td>
         </tr>
         <tr>
            <td>Jetty</td>
            <td>Mort Bay Consulting, 1995</td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td>Реализован полностью на Java.</td>
         </tr>
         <tr>
            <td>nginx</td>
            <td>Игорь Сысоев, 2002</td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td>Разрабатывался для испытывающих большую нагрузку серверов. Включает в себя почтовый прокси-сервер.</td>
         </tr>
         <tr>
            <td>lighttpd</td>
            <td>Jan Kneschke,февраль 2003</td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td>Использование на сильно нагруженных серверах, обеспечение быстроты и защищённости.</td>
         </tr>
         <tr>
            <td>NodeJS</td>
            <td>Ryan Lienhart Dahl, 2009</td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td>Асинхронный язык высокого уровня</td>
         </tr>
         <tr>
            <td>Tornado</td>
            <td>FriendFeed, 2009</td>
            <td><span class='glyphicon glyphicon-ok'></span></td>
            <td>Асинхронный сервер, написан на питоне</td>
         </tr>
         </tbody>
      </table>
   </div>
</div>

</div>
</body>
</html>
